# models_mapping.md

## Цель
Зафиксировать, как Django-модели и их ограничения переносятся в SQLAlchemy 2.0 (async), без ломки API-контракта.

## Конвенции (кратко)
- Имена таблиц/колонок — `snake_case`.
- Ключи/индексы: `pk_<table>`, `fk_<table>__<col>__<reftable>`, `uq_<table>__...`, `ix_<table>__<col>`, `ck_<table>__<name>`.
- Даты/время: `TIMESTAMP(timezone=True)`, UTC, `server_default=now()`, `onupdate=now()`.
- Загрузки: коллекции — `selectinload`.

---

## Ingredient → SA: `ingredients`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `name: VARCHAR(200) NOT NULL` (`db_index=True`)
- `measurement_unit: VARCHAR(200) NOT NULL`
- `created: TIMESTAMPTZ NOT NULL DEFAULT now()`
- `updated: TIMESTAMPTZ NOT NULL DEFAULT now() ON UPDATE now()`

**Ограничения/индексы:**
- `UniqueConstraint(name, measurement_unit, name='uq_ingredients__name__measurement_unit')`
- `Index ix_ingredients__name (name)`

**Отношения:**
- M2M с `recipes` через `recipe_ingredient_amount`.

---

## Tag → SA: `tags`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `name: VARCHAR(200) NOT NULL UNIQUE`
- `color: VARCHAR(7) NOT NULL UNIQUE`
- `slug: VARCHAR(200) NOT NULL UNIQUE`
- `created: TIMESTAMPTZ NOT NULL DEFAULT now()`
- `updated: TIMESTAMPTZ NOT NULL DEFAULT now() ON UPDATE now()`

**Ограничения/индексы:**
- `uq_tags__name`, `uq_tags__color`, `uq_tags__slug`

**Отношения:**
- M2M с `recipes` через `recipe_tags`.

---

## Recipe → SA: `recipes`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `author_id: BIGINT NOT NULL` → FK `users.id` `ondelete='CASCADE'`
- `name: VARCHAR(200) NOT NULL`
- `image: VARCHAR(?) NULL`
- `text: TEXT NOT NULL`
- `cooking_time: SMALLINT NOT NULL CHECK (cooking_time >= 1)`
- `pub_date: TIMESTAMPTZ NOT NULL DEFAULT now()`
- `created: TIMESTAMPTZ NOT NULL DEFAULT now()`
- `updated: TIMESTAMPTZ NOT NULL DEFAULT now() ON UPDATE now()`

**Ограничения/индексы:**
- `Index ix_recipes__pub_date (pub_date)`
- `Index ix_recipes__author_id (author_id)`

**Отношения:**
- N:1 `author` → `users`
- M2M `ingredients` через `recipe_ingredient_amount`
- M2M `tags` через `recipe_tags`

---

## RecipeIngredientAmount → SA: `recipe_ingredient_amount`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `ingredient_id: BIGINT NOT NULL` → FK `ingredients.id` `ondelete='CASCADE'`
- `recipe_id: BIGINT NOT NULL` → FK `recipes.id` `ondelete='CASCADE'`
- `amount: SMALLINT NOT NULL CHECK (amount >= 1)`

**Ограничения/индексы:**
- `UniqueConstraint(recipe_id, ingredient_id, name='uq_recipe_ingredient_amount__recipe__ingredient')`
- `Index ix_recipe_ingredient_amount__ingredient_id (ingredient_id)`
- `Index ix_recipe_ingredient_amount__recipe_id (recipe_id)`

---

## RecipeTags → SA: `recipe_tags`
**Поля:**
- `recipe_id: BIGINT NOT NULL` → FK `recipes.id` `ondelete='CASCADE'`
- `tag_id: BIGINT NOT NULL` → FK `tags.id` `ondelete='CASCADE'`

**Ограничения/индексы:**
- `UniqueConstraint(recipe_id, tag_id, name='uq_recipe_tags__recipe__tag')`
- `Index ix_recipe_tags__tag_id (tag_id)`
- `Index ix_recipe_tags__recipe_id (recipe_id)`

---

## Favorite → SA: `favorites`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `user_id: BIGINT NOT NULL` → FK `users.id` `ondelete='CASCADE'`
- `recipe_id: BIGINT NOT NULL` → FK `recipes.id` `ondelete='CASCADE'`

**Ограничения/индексы:**
- `UniqueConstraint(user_id, recipe_id, name='uq_favorites__user__recipe')`
- `Index ix_favorites__user_id (user_id)`
- `Index ix_favorites__recipe_id (recipe_id)`

---

## ShoppingCart → SA: `shopping_carts`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `user_id: BIGINT NOT NULL` → FK `users.id` `ondelete='CASCADE'`
- `recipe_id: BIGINT NOT NULL` → FK `recipes.id` `ondelete='CASCADE'`

**Ограничения/индексы:**
- `UniqueConstraint(user_id, recipe_id, name='uq_shopping_carts__user__recipe')`
- `Index ix_shopping_carts__user_id (user_id)`
- `Index ix_shopping_carts__recipe_id (recipe_id)`

---

## User → SA: `users`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `first_name: VARCHAR(200) NULL`
- `last_name: VARCHAR(200) NULL`
- `username: VARCHAR(200) NOT NULL UNIQUE`
- `email: VARCHAR(200) NOT NULL UNIQUE`

**Ограничения/индексы:**
- `uq_users__username`, `uq_users__email`
- (опц.) `ix_users__username`, `ix_users__email`

**Отношения:**
- 1:N `recipes` (автор)

---

## Follow → SA: `follows`
**PK:** `id BIGINT GENERATED BY DEFAULT AS IDENTITY`
**Поля:**
- `user_id: BIGINT NOT NULL` → FK `users.id` `ondelete='CASCADE'`
- `following_id: BIGINT NOT NULL` → FK `users.id` `ondelete='CASCADE'`

**Ограничения/индексы:**
- `UniqueConstraint(user_id, following_id, name='uq_follows__user__following')`
- `CheckConstraint(user_id <> following_id, name='ck_follows__no_self_follow')`
- `Index ix_follows__user_id (user_id)`
- `Index ix_follows__following_id (following_id)`

---

## Заметки по Alembic
1) #001: `users`, `ingredients`, `tags`
2) #002: `recipes`, `recipe_ingredient_amount`, `recipe_tags`
3) #003: `favorites`, `shopping_carts`, `follows`
4) Сиды: `ingredients` из `data/ingredients.json` после #001
5) `updated` обновляется через `onupdate=func.now()` (SQLAlchemy) или серверный триггер (опционально)
